<!-- Generated by SpecStory -->

# 2025-12-21 17:47:28Z

<!-- Claude Code Session 1cf4daaa-7537-46b3-a6f4-0c07bf519f5b (2025-12-21_17-47-28Z) -->

_**User (sidechain)**_

Explore the CLI theme and styling implementation in this codebase:

1. Read scripts/cli/theme.ts thoroughly - understand how styling is done
2. Look at how existing CLI scripts use the theme
3. Check package.json for any existing CLI/TUI dependencies (inquirer, prompts, ink, blessed, etc.)
4. Look for any interactive CLI patterns already in the codebase

I need to understand the existing patterns before designing a new interactive CLI.

---

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

I'll help you explore the CLI theme and styling implementation. Let me start by searching for the theme file and examining the codebase structure.

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Glob**

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Glob**

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Read** `./package.json`

Result:

```
1→{
     2→  "name": "dmitrii-portfolio",
     3→  "private": true,
     4→  "version": "0.0.0",
     5→  "type": "module",
     6→  "scripts": {
     7→    "dev": "vite",
     8→    "predev": "npm run variants:sync",
     9→    "build": "tsc -b && vite build",
    10→    "postbuild": "cp dist/index.html dist/404.html",
    11→    "prebuild": "npm run validate && npm run variants:sync",
    12→    "lint": "eslint .",
    13→    "preview": "vite preview",
    14→    "test": "vitest run",
    15→    "test:watch": "vitest",
    16→    "test:design-system": "vitest run --reporter=verbose src/tests/design-system",
    17→    "validate": "tsx scripts/validate-content.ts",
    18→    "generate:cv": "tsx scripts/generate-cv.ts",
    19→    "generate:og": "node scripts/generate-og-images.js",
    20→    "variants:sync": "tsx scripts/sync-variants.ts",
    21→    "variants:check": "tsx scripts/sync-variants.ts --check",
    22→    "eval:variant": "tsx scripts/evaluate-variants.ts",
    23→    "eval:all": "tsx scripts/evaluate-variants.ts --all",
    24→    "eval:check": "tsx scripts/evaluate-variants.ts --check --all",
    25→    "redteam:variant": "tsx scripts/redteam.ts",
    26→    "redteam:all": "tsx scripts/redteam.ts --all",
    27→    "redteam:check": "tsx scripts/redteam.ts --check --all"
    28→  },
    29→  "dependencies": {
    30→    "@types/react-syntax-highlighter": "^15.5.13",
    31→    "framer-motion": "^12.23.26",
    32→    "gray-matter": "^4.0.3",
    33→    "react": "^19.2.0",
    34→    "react-dom": "^19.2.0",
    35→    "react-helmet-async": "^2.0.5",
    36→    "react-markdown": "^10.1.0",
    37→    "react-router-dom": "^6.30.2",
    38→    "react-syntax-highlighter": "^16.1.0",
    39→    "remark-gfm": "^4.0.1",
    40→    "yaml": "^2.8.2",
    41→    "zod": "^4.1.13"
    42→  },
    43→  "overrides": {
    44→    "react-helmet-async": {
    45→      "react": "$react",
    46→      "react-dom": "$react-dom"
    47→    }
    48→  },
    49→  "devDependencies": {
    50→    "@eslint/js": "^9.39.1",
    51→    "@rollup/plugin-yaml": "^4.1.2",
    52→    "@testing-library/dom": "^10.4.1",
    53→    "@testing-library/jest-dom": "^6.9.1",
    54→    "@testing-library/react": "^16.3.0",
    55→    "@types/node": "^24.10.4",
    56→    "@types/react": "^19.2.5",
    57→    "@types/react-dom": "^19.2.3",
    58→    "@types/testing-library__jest-dom": "^5.14.9",
    59→    "@vitejs/plugin-react": "^5.1.1",
    60→    "chalk": "^5.6.2",
    61→    "eslint": "^9.39.1",
    62→    "eslint-plugin-react-hooks": "^7.0.1",
    63→    "eslint-plugin-react-refresh": "^0.4.24",
    64→    "globals": "^16.5.0",
    65→    "jsdom": "^27.0.1",
    66→    "ora": "^9.0.0",
    67→    "puppeteer": "^24.34.0",
    68→    "tsx": "^4.21.0",
    69→    "typescript": "~5.9.3",
    70→    "typescript-eslint": "^8.46.4",
    71→    "vite": "^7.2.4",
    72→    "vitest": "^3.2.4"
    73→  }
    74→}
    75→
```

Result:

```
/Users/dfotesco/Portfolio/portfolio/scripts/cli/theme.ts
```

Result:

```
/Users/dfotesco/Portfolio/portfolio/scripts/cli/theme.ts
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Now let me read the theme.ts file and look for CLI scripts that use it:

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Read** `./scripts/cli/theme.ts`

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Glob**

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Bash** List TypeScript files in scripts directory

`find /Users/dfotesco/Portfolio/portfolio/scripts -type f -name "*.ts" | head -20`

Result:

```
1→/**
     2→ * Universal CV CLI Theme
     3→ *
     4→ * Design tokens and utilities for consistent CLI output.
     5→ * Colors derived from the portfolio design system (globals.css)
     6→ */
     7→
     8→import chalk from 'chalk';
     9→
    10→// Brand colors from globals.css
    11→const BRAND = {
    12→  accent: '#c29a6c',      // --color-accent (dark mode)
    13→  accentLight: '#8a6642', // --color-accent (light mode)
    14→  success: '#4ade80',     // --color-success
    15→  warning: '#facc15',     // Yellow for warnings
    16→  error: '#ef4444',       // --color-danger
    17→  info: '#60a5fa',        // Blue for info
    18→  muted: '#6b7280',       // Gray for secondary text
    19→};
    20→
    21→// Semantic color functions
    22→export const theme = {
    23→  // Brand
    24→  brand: chalk.hex(BRAND.accent),
    25→  brandBold: chalk.hex(BRAND.accent).bold,
    26→
    27→  // Semantic
    28→  success: chalk.hex(BRAND.success),
    29→  warning: chalk.hex(BRAND.warning),
    30→  error: chalk.hex(BRAND.error),
    31→  info: chalk.hex(BRAND.info),
    32→  muted: chalk.hex(BRAND.muted),
    33→
    34→  // Text variants
    35→  bold: chalk.bold,
    36→  dim: chalk.dim,
    37→  italic: chalk.italic,
    38→
    39→  // Status icons with colors
    40→  icons: {
    41→    success: chalk.hex(BRAND.success)('✓'),
    42→    error: chalk.hex(BRAND.error)('✗'),
    43→    warning: chalk.hex(BRAND.warning)('⚠'),
    44→    info: chalk.hex(BRAND.info)('ℹ'),
    45→    pending: chalk.hex(BRAND.muted)('○'),
    46→    running: chalk.hex(BRAND.info)('●'),
    47→    bullet: chalk.hex(BRAND.muted)('•'),
    48→  },
    49→
    50→  // For pass/fail/warn badges
    51→  badge: {
    52→    pass: chalk.hex(BRAND.success).bold('PASS'),
    53→    fail: chalk.hex(BRAND.error).bold('FAIL'),
    54→    warn: chalk.hex(BRAND.warning).bold('WARN'),
    55→  },
    56→};
    57→
    58→// ASCII Art header - compact version for subcommands
    59→export const HEADER_COMPACT = `
    60→${chalk.hex(BRAND.accent)('╭─────────────────────────────────────────────────────────────────────────────╮')}
    61→${chalk.hex(BRAND.accent)('│')}  ${chalk.hex(BRAND.accent).bold('◆ Universal CV')}                                          ${chalk.dim('Quality Pipeline')}  ${chalk.hex(BRAND.accent)('│')}
    62→${chalk.hex(BRAND.accent)('╰─────────────────────────────────────────────────────────────────────────────╯')}
    63→`.trim();
    64→
    65→// Full ASCII art logo for main entry point
    66→export const HEADER_FULL = `
    67→${chalk.hex(BRAND.accent)('    ██╗   ██╗███╗   ██╗██╗██╗   ██╗███████╗██████╗ ███████╗ █████╗ ██╗')}
    68→${chalk.hex(BRAND.accent)('    ██║   ██║████╗  ██║██║██║   ██║██╔════╝██╔══██╗██╔════╝██╔══██╗██║')}
    69→${chalk.hex(BRAND.accent)('    ██║   ██║██╔██╗ ██║██║██║   ██║█████╗  ██████╔╝███████╗███████║██║')}
    70→${chalk.hex(BRAND.accent)('    ██║   ██║██║╚██╗██║██║╚██╗ ██╔╝██╔══╝  ██╔══██╗╚════██║██╔══██║██║')}
    71→${chalk.hex(BRAND.accent)('    ╚██████╔╝██║ ╚████║██║ ╚████╔╝ ███████╗██║  ██║███████║██║  ██║███████╗')}
    72→${chalk.hex(BRAND.accent)('     ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═══╝  ╚══════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝')}
    73→${chalk.hex(BRAND.accent)('                             ██████╗██╗   ██╗')}
    74→${chalk.hex(BRAND.accent)('                            ██╔════╝██║   ██║')}
    75→${chalk.hex(BRAND.accent)('                            ██║     ██║   ██║')}
    76→${chalk.hex(BRAND.accent)('                            ██║     ╚██╗ ██╔╝')}
    77→${chalk.hex(BRAND.accent)('                            ╚██████╗ ╚████╔╝')}
    78→${chalk.hex(BRAND.accent)('                             ╚═════╝  ╚═══╝')}
    79→
    80→${chalk.dim('                   AI-Powered Portfolio Quality Pipeline')}
    81→`.trim();
    82→
    83→/**
    84→ * Print a section header
    85→ */
    86→export function header(title: string, subtitle?: string): string {
    87→  const line = chalk.hex(BRAND.muted)('─'.repeat(75));
    88→  const header = `${chalk.hex(BRAND.accent).bold(title)}${subtitle ? chalk.dim(` · ${subtitle}`) : ''}`;
    89→  return `\n${header}\n${line}`;
    90→}
    91→
    92→/**
    93→ * Print a box around content
    94→ */
    95→export function box(title: string, content: string): string {
    96→  const lines = content.split('\n');
    97→  const maxWidth = Math.max(title.length + 4, ...lines.map(l => stripAnsi(l).length + 4));
    98→  const width = Math.min(maxWidth, 77);
    99→
   100→  const accent = chalk.hex(BRAND.accent);
   101→  const top = `${accent('╭─')} ${chalk.bold(title)} ${accent('─'.repeat(Math.max(0, width - title.length - 5)))}${accent('╮')}`;
   102→  const bottom = `${accent('╰')}${accent('─'.repeat(width - 1))}${accent('╯')}`;
   103→
   104→  const body = lines.map(line => {
   105→    const stripped = stripAnsi(line);
   106→    const padding = Math.max(0, width - stripped.length - 4);
   107→    return `${accent('│')} ${line}${' '.repeat(padding)} ${accent('│')}`;
   108→  }).join('\n');
   109→
   110→  return [top, body, bottom].join('\n');
   111→}
   112→
   113→/**
   114→ * Format a key-value pair
   115→ */
   116→export function kv(key: string, value: string): string {
   117→  return `${chalk.dim(key + ':')} ${value}`;
   118→}
   119→
   120→/**
   121→ * Format a list item
   122→ */
   123→export function li(text: string, indent = 0): string {
   124→  return `${'  '.repeat(indent)}${theme.icons.bullet} ${text}`;
   125→}
   126→
   127→/**
   128→ * Format a step in a process
   129→ */
   130→export function step(status: 'pending' | 'running' | 'success' | 'error', text: string): string {
   131→  const icon = theme.icons[status] || theme.icons.pending;
   132→  return `${icon} ${text}`;
   133→}
   134→
   135→/**
   136→ * Simple progress bar
   137→ */
   138→export function progressBar(percent: number, width = 40): string {
   139→  const filled = Math.round((percent / 100) * width);
   140→  const empty = width - filled;
   141→  return `${chalk.hex(BRAND.success)('█'.repeat(filled))}${chalk.dim('░'.repeat(empty))} ${percent.toFixed(0)}%`;
   142→}
   143→
   144→/**
   145→ * Strip ANSI codes from a string (for width calculation)
   146→ */
   147→function stripAnsi(str: string): string {
   148→  // eslint-disable-next-line no-control-regex
   149→  return str.replace(/\x1B\[[0-9;]*m/g, '');
   150→}
   151→
   152→/**
   153→ * Detect if running in interactive mode
   154→ */
   155→export function isInteractive(): boolean {
   156→  return process.stdin.isTTY === true &&
   157→         process.stdout.isTTY === true &&
   158→         !process.env.CI &&
   159→         !process.env.UCV_NON_INTERACTIVE;
   160→}
   161→
   162→/**
   163→ * Check if colors should be disabled
   164→ */
   165→export function shouldUseColor(): boolean {
   166→  return !process.env.NO_COLOR &&
   167→         !process.env.UCV_NO_COLOR &&
   168→         (process.stdout.isTTY === true || process.env.FORCE_COLOR === '1');
   169→}
   170→
```

Result:

```
/Users/dfotesco/Portfolio/portfolio/scripts/evaluate-variants.ts
/Users/dfotesco/Portfolio/portfolio/scripts/redteam.ts
/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts
/Users/dfotesco/Portfolio/portfolio/scripts/cli/theme.ts
/Users/dfotesco/Portfolio/portfolio/scripts/validate-content.ts
/Users/dfotesco/Portfolio/portfolio/scripts/generate-cv.ts
```

Result:

```
/Users/dfotesco/Portfolio/portfolio/scripts/generate-cv.ts
/Users/dfotesco/Portfolio/portfolio/scripts/validate-content.ts
/Users/dfotesco/Portfolio/portfolio/scripts/cli/theme.ts
/Users/dfotesco/Portfolio/portfolio/scripts/evaluate-variants.ts
/Users/dfotesco/Portfolio/portfolio/scripts/redteam.ts
/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Now let me examine the CLI scripts to see how they use the theme:

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Read** `./scripts/validate-content.ts`

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Read** `./scripts/generate-cv.ts`

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Read** `./scripts/sync-variants.ts`

Result:

```
1→#!/usr/bin/env tsx
     2→/**
     3→ * Content Validation CLI
     4→ *
     5→ * Validates all portfolio content files against Zod schemas.
     6→ * Run before committing to catch content errors early.
     7→ *
     8→ * Usage:
     9→ *   npm run validate
    10→ */
    11→
    12→import { readFileSync, readdirSync } from 'fs';
    13→import { join } from 'path';
    14→import YAML from 'yaml';
    15→import { z } from 'zod';
    16→import {
    17→  ProfileSchema,
    18→  ExperienceSchema,
    19→  TestimonialsSchema,
    20→  CertificationsSchema,
    21→  SkillsSchema,
    22→  SocialSchema,
    23→  CaseStudySchema,
    24→  PassionProjectsSchema,
    25→  BlogPostSchema,
    26→  VariantSchema
    27→} from '../src/lib/schemas.js';
    28→
    29→// ANSI color codes for terminal output
    30→const colors = {
    31→  reset: '\x1b[0m',
    32→  green: '\x1b[32m',
    33→  red: '\x1b[31m',
    34→  yellow: '\x1b[33m',
    35→  blue: '\x1b[34m',
    36→  gray: '\x1b[90m'
    37→};
    38→
    39→interface ValidationResult {
    40→  file: string;
    41→  success: boolean;
    42→  errors?: string[];
    43→}
    44→
    45→// Parse frontmatter from markdown
    46→function parseFrontmatter(raw: string): { frontmatter: Record<string, unknown>; content: string } {
    47→  const match = raw.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
    48→  if (!match) return { frontmatter: {}, content: raw };
    49→
    50→  const frontmatterStr = match[1];
    51→  const content = match[2].trim();
    52→
    53→  try {
    54→    const frontmatter = YAML.parse(frontmatterStr);
    55→    return { frontmatter, content };
    56→  } catch (error) {
    57→    console.error('Failed to parse frontmatter:', error);
    58→    return { frontmatter: {}, content: raw };
    59→  }
    60→}
    61→
    62→// Validate a single file against a Zod schema
    63→function validateFile(
    64→  filePath: string,
    65→  schema: z.ZodSchema,
    66→  data: unknown
    67→): ValidationResult {
    68→  try {
    69→    schema.parse(data);
    70→    return { file: filePath, success: true };
    71→  } catch (error) {
    72→    if (error instanceof z.ZodError) {
    73→      const errors = error.errors.map(err => {
    74→        const path = err.path.join('.');
    75→        return `  ${colors.red}✗${colors.reset} ${path}: ${err.message}`;
    76→      });
    77→      return { file: filePath, success: false, errors };
    78→    }
    79→    return {
    80→      file: filePath,
    81→      success: false,
    82→      errors: [`  ${colors.red}✗${colors.reset} Unknown error: ${error}`]
    83→    };
    84→  }
    85→}
    86→
    87→// Validate YAML files
    88→function validateYamlFile(filePath: string, schema: z.ZodSchema): ValidationResult {
    89→  try {
    90→    const content = readFileSync(filePath, 'utf-8');
    91→    const data = YAML.parse(content);
    92→    return validateFile(filePath, schema, data);
    93→  } catch (error) {
    94→    return {
    95→      file: filePath,
    96→      success: false,
    97→      errors: [`  ${colors.red}✗${colors.reset} Failed to read/parse: ${error}`]
    98→    };
    99→  }
   100→}
   101→
   102→// Validate markdown files with frontmatter
   103→function validateMarkdownFile(filePath: string, schema: z.ZodSchema): ValidationResult {
   104→  try {
   105→    const content = readFileSync(filePath, 'utf-8');
   106→    const { frontmatter, content: body } = parseFrontmatter(content);
   107→
   108→    // Combine frontmatter with content for validation
   109→    const data = { ...frontmatter, content: body };
   110→    return validateFile(filePath, schema, data);
   111→  } catch (error) {
   112→    return {
   113→      file: filePath,
   114→      success: false,
   115→      errors: [`  ${colors.red}✗${colors.reset} Failed to read/parse: ${error}`]
   116→    };
   117→  }
   118→}
   119→
   120→// Main validation function
   121→async function validateAllContent(): Promise<void> {
   122→  console.log(`${colors.blue}Validating portfolio content...${colors.reset}\n`);
   123→
   124→  const results: ValidationResult[] = [];
   125→  const contentDir = join(process.cwd(), 'content');
   126→
   127→  // Validate single YAML files
   128→  const singleYamlFiles = [
   129→    { path: 'profile.yaml', schema: ProfileSchema, label: 'Profile' },
   130→    { path: 'experience/index.yaml', schema: ExperienceSchema, label: 'Experience' },
   131→    { path: 'testimonials/index.yaml', schema: TestimonialsSchema, label: 'Testimonials' },
   132→    { path: 'certifications/index.yaml', schema: CertificationsSchema, label: 'Certifications' },
   133→    { path: 'skills/index.yaml', schema: SkillsSchema, label: 'Skills' },
   134→    { path: 'social/index.yaml', schema: SocialSchema, label: 'Social' },
   135→    { path: 'passion-projects/index.yaml', schema: PassionProjectsSchema, label: 'Passion Projects' }
   136→  ];
   137→
   138→  console.log(`${colors.gray}Validating YAML files...${colors.reset}`);
   139→  for (const { path, schema, label } of singleYamlFiles) {
   140→    const fullPath = join(contentDir, path);
   141→    const result = validateYamlFile(fullPath, schema);
   142→    results.push(result);
   143→
   144→    if (result.success) {
   145→      console.log(`${colors.green}✓${colors.reset} ${label} (${path})`);
   146→    } else {
   147→      console.log(`${colors.red}✗${colors.reset} ${label} (${path})`);
   148→      result.errors?.forEach(err => console.log(err));
   149→    }
   150→  }
   151→
   152→  // Validate case studies
   153→  console.log(`\n${colors.gray}Validating case studies...${colors.reset}`);
   154→  const caseStudiesDir = join(contentDir, 'case-studies');
   155→  const caseStudyFiles = readdirSync(caseStudiesDir).filter(f => f.endsWith('.md'));
   156→
   157→  for (const file of caseStudyFiles) {
   158→    const fullPath = join(caseStudiesDir, file);
   159→    const result = validateMarkdownFile(fullPath, CaseStudySchema);
   160→    results.push(result);
   161→
   162→    if (result.success) {
   163→      console.log(`${colors.green}✓${colors.reset} Case Study: ${file}`);
   164→    } else {
   165→      console.log(`${colors.red}✗${colors.reset} Case Study: ${file}`);
   166→      result.errors?.forEach(err => console.log(err));
   167→    }
   168→  }
   169→
   170→  // Validate blog posts
   171→  console.log(`\n${colors.gray}Validating blog posts...${colors.reset}`);
   172→  const blogDir = join(contentDir, 'blog');
   173→  const blogFiles = readdirSync(blogDir).filter(f => f.endsWith('.md'));
   174→
   175→  for (const file of blogFiles) {
   176→    const fullPath = join(blogDir, file);
   177→    const result = validateMarkdownFile(fullPath, BlogPostSchema);
   178→    results.push(result);
   179→
   180→    if (result.success) {
   181→      console.log(`${colors.green}✓${colors.reset} Blog Post: ${file}`);
   182→    } else {
   183→      console.log(`${colors.red}✗${colors.reset} Blog Post: ${file}`);
   184→      result.errors?.forEach(err => console.log(err));
   185→    }
   186→  }
   187→
   188→  // Validate variants
   189→  console.log(`\n${colors.gray}Validating portfolio variants...${colors.reset}`);
   190→  const variantsDir = join(contentDir, 'variants');
   191→  try {
   192→    const variantFiles = readdirSync(variantsDir).filter(f => f.endsWith('.yaml') && !f.startsWith('_'));
   193→
   194→    if (variantFiles.length === 0) {
   195→      console.log(`${colors.gray}  No variants found (this is OK)${colors.reset}`);
   196→    } else {
   197→      for (const file of variantFiles) {
   198→        const fullPath = join(variantsDir, file);
   199→        const result = validateYamlFile(fullPath, VariantSchema);
   200→        results.push(result);
   201→
   202→        if (result.success) {
   203→          console.log(`${colors.green}✓${colors.reset} Variant: ${file}`);
   204→        } else {
   205→          console.log(`${colors.red}✗${colors.reset} Variant: ${file}`);
   206→          result.errors?.forEach(err => console.log(err));
   207→        }
   208→      }
   209→    }
   210→  } catch (error) {
   211→    console.log(`${colors.gray}  Variants directory not found (this is OK)${colors.reset}`);
   212→  }
   213→
   214→  // Summary
   215→  const passed = results.filter(r => r.success).length;
   216→  const failed = results.filter(r => !r.success).length;
   217→
   218→  console.log('\n' + '─'.repeat(50));
   219→  if (failed === 0) {
   220→    console.log(`${colors.green}✓ All ${passed} content files validated successfully!${colors.reset}`);
   221→    process.exit(0);
   222→  } else {
   223→    console.log(`${colors.red}✗ ${failed} file(s) failed validation${colors.reset}`);
   224→    console.log(`${colors.green}✓ ${passed} file(s) passed${colors.reset}`);
   225→    process.exit(1);
   226→  }
   227→}
   228→
   229→// Run validation
   230→validateAllContent().catch((error) => {
   231→  console.error(`${colors.red}Fatal error:${colors.reset}`, error);
   232→  process.exit(1);
   233→});
   234→
```

Result:

```
1→#!/usr/bin/env tsx
     2→/**
     3→ * Universal CV Generator CLI
     4→ *
     5→ * Generates personalized portfolio variants for specific job applications
     6→ * using AI to analyze job descriptions and tailor content.
     7→ *
     8→ * Usage:
     9→ *   npm run generate:cv -- --company "Bloomberg" --role "Senior Engineer" --jd "./jd.txt"
    10→ *   npm run generate:cv -- --company "Gensyn" --role "ML Researcher" --jd-text "Job description..."
    11→ *
    12→ * Options:
    13→ *   --company <name>         Company name (required)
    14→ *   --role <title>          Role title (required)
    15→ *   --jd <file>             Path to job description file
    16→ *   --jd-text <text>        Job description as text
    17→ *   --values <text>         Company values (optional)
    18→ *   --context <text>        Additional context (optional)
    19→ *   --provider <name>       AI provider: claude | openai | gemini (default: claude)
    20→ *   --api-key <key>         API key (or use env var)
    21→ *   --output <file>         Output file path (auto-generated if not specified)
    22→ */
    23→
    24→import { readFileSync, writeFileSync, readdirSync } from 'fs';
    25→import { join } from 'path';
    26→import YAML from 'yaml';
    27→import { VariantSchema } from '../src/lib/schemas.js';
    28→
    29→// ANSI color codes
    30→const colors = {
    31→  reset: '\x1b[0m',
    32→  green: '\x1b[32m',
    33→  red: '\x1b[31m',
    34→  yellow: '\x1b[33m',
    35→  blue: '\x1b[34m',
    36→  cyan: '\x1b[36m',
    37→  gray: '\x1b[90m',
    38→  bold: '\x1b[1m'
    39→};
    40→
    41→interface CLIArgs {
    42→  company: string;
    43→  role: string;
    44→  jobDescription: string;
    45→  companyValues?: string;
    46→  additionalContext?: string;
    47→  provider: 'claude' | 'openai' | 'gemini';
    48→  apiKey?: string;
    49→  outputFile?: string;
    50→}
    51→
    52→interface PortfolioData {
    53→  profile: any;
    54→  experience: any;
    55→  caseStudies: any[];
    56→  skills: any;
    57→  projects: any;
    58→}
    59→
    60→// Parse command line arguments
    61→function parseArgs(): CLIArgs {
    62→  const args = process.argv.slice(2);
    63→  const parsed: any = {
    64→    provider: 'claude'
    65→  };
    66→
    67→  for (let i = 0; i < args.length; i++) {
    68→    const arg = args[i];
    69→    const next = args[i + 1];
    70→
    71→    switch (arg) {
    72→      case '--company':
    73→        parsed.company = next;
    74→        i++;
    75→        break;
    76→      case '--role':
    77→        parsed.role = next;
    78→        i++;
    79→        break;
    80→      case '--jd':
    81→        parsed.jobDescription = readFileSync(next, 'utf-8');
    82→        i++;
    83→        break;
    84→      case '--jd-text':
    85→        parsed.jobDescription = next;
    86→        i++;
    87→        break;
    88→      case '--values':
    89→        parsed.companyValues = next;
    90→        i++;
    91→        break;
    92→      case '--context':
    93→        parsed.additionalContext = next;
    94→        i++;
    95→        break;
    96→      case '--provider':
    97→        if (!['claude', 'openai', 'gemini'].includes(next)) {
    98→          throw new Error(`Invalid provider: ${next}. Must be: claude, openai, or gemini`);
    99→        }
   100→        parsed.provider = next;
   101→        i++;
   102→        break;
   103→      case '--api-key':
   104→        parsed.apiKey = next;
   105→        i++;
   106→        break;
   107→      case '--output':
   108→        parsed.outputFile = next;
   109→        i++;
   110→        break;
   111→    }
   112→  }
   113→
   114→  // Validation
   115→  if (!parsed.company) {
   116→    throw new Error('Missing required argument: --company');
   117→  }
   118→  if (!parsed.role) {
   119→    throw new Error('Missing required argument: --role');
   120→  }
   121→  if (!parsed.jobDescription) {
   122→    throw new Error('Missing required argument: --jd or --jd-text');
   123→  }
   124→
   125→  // Get API key from env if not provided
   126→  if (!parsed.apiKey) {
   127→    const envVars = {
   128→      claude: 'ANTHROPIC_API_KEY',
   129→      openai: 'OPENAI_API_KEY',
   130→      gemini: 'GEMINI_API_KEY'
   131→    };
   132→    parsed.apiKey = process.env[envVars[parsed.provider]];
   133→
   134→    if (!parsed.apiKey) {
   135→      throw new Error(
   136→        `No API key found. Set ${envVars[parsed.provider]} environment variable or use --api-key`
   137→      );
   138→    }
   139→  }
   140→
   141→  return parsed as CLIArgs;
   142→}
   143→
   144→// Load all portfolio content
   145→function loadPortfolioData(): PortfolioData {
   146→  const contentDir = join(process.cwd(), 'content');
   147→
   148→  console.log(`${colors.gray}Loading portfolio content...${colors.reset}`);
   149→
   150→  // Load YAML files
   151→  const profile = YAML.parse(readFileSync(join(contentDir, 'profile.yaml'), 'utf-8'));
   152→  const experience = YAML.parse(readFileSync(join(contentDir, 'experience/index.yaml'), 'utf-8'));
   153→  const skills = YAML.parse(readFileSync(join(contentDir, 'skills/index.yaml'), 'utf-8'));
   154→  const projects = YAML.parse(readFileSync(join(contentDir, 'passion-projects/index.yaml'), 'utf-8'));
   155→
   156→  // Load case studies
   157→  const caseStudiesDir = join(contentDir, 'case-studies');
   158→  const caseStudyFiles = readdirSync(caseStudiesDir).filter(f => f.endsWith('.md'));
   159→
   160→  const caseStudies = caseStudyFiles.map(file => {
   161→    const content = readFileSync(join(caseStudiesDir, file), 'utf-8');
   162→    const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
   163→
   164→    if (match) {
   165→      const frontmatter = YAML.parse(match[1]);
   166→      const body = match[2].trim();
   167→      return { ...frontmatter, content: body };
   168→    }
   169→    return null;
   170→  }).filter(Boolean);
   171→
   172→  console.log(`${colors.green}✓${colors.reset} Loaded ${experience.jobs.length} jobs, ${caseStudies.length} case studies, ${skills.categories.length} skill categories`);
   173→
   174→  return { profile, experience, caseStudies, skills, projects };
   175→}
   176→
   177→// Generate the AI prompt
   178→function generatePrompt(args: CLIArgs, data: PortfolioData): string {
   179→  return `You are an expert career consultant helping personalize a portfolio website for a specific job application.
   180→
   181→# Job Application
   182→Company: ${args.company}
   183→Role: ${args.role}
   184→
   185→${args.companyValues ? `Company Values:\n${args.companyValues}\n` : ''}
   186→${args.additionalContext ? `Additional Context:\n${args.additionalContext}\n` : ''}
   187→
   188→Job Description:
   189→${args.jobDescription}
   190→
   191→# Portfolio Owner's Background
   192→
   193→## Current Profile
   194→${YAML.stringify(data.profile)}
   195→
   196→## Experience
   197→${YAML.stringify(data.experience)}
   198→
   199→## Case Studies (${data.caseStudies.length} available)
   200→${data.caseStudies.map(cs => `- ${cs.title} (${cs.slug}): ${cs.hook?.headline || 'No headline'}`).join('\n')}
   201→
   202→## Skills
   203→${YAML.stringify(data.skills)}
   204→
   205→## Passion Projects
   206→${YAML.stringify(data.projects)}
   207→
   208→# Your Task
   209→
   210→Generate a personalized portfolio variant as a YAML object with this exact structure:
   211→
   212→\`\`\`yaml
   213→metadata:
   214→  company: "${args.company}"
   215→  role: "${args.role}"
   216→  slug: "company-role-slug"  # lowercase-hyphenated
   217→  generatedAt: "${new Date().toISOString()}"
   218→  jobDescription: |
   219→    ${args.jobDescription.split('\n').map(line => `    ${line}`).join('\n')}
   220→  generationModel: "your-model-name"
   221→
   222→overrides:
   223→  hero:
   224→    status: "Open to [relevant role type] roles — [relevant domains]"
   225→    headline:
   226→      - text: "word1"
   227→        style: "italic"  # or normal
   228→      - text: "connecting phrase"
   229→        style: "muted"
   230→      - text: "key value proposition"
   231→        style: "accent"
   232→    subheadline: |
   233→      One-sentence pitch emphasizing most relevant experience
   234→      for this specific role and company. Use concrete achievements.
   235→
   236→  about:
   237→    tagline: |
   238→      Two-sentence professional summary highlighting the intersection
   239→      of candidate's experience with this company's needs.
   240→    bio:
   241→      - |
   242→        First paragraph: Current role and most relevant recent experience.
   243→        Emphasize projects/technologies mentioned in the job description.
   244→        Make it feel tailored to this opportunity.
   245→      - |
   246→        Second paragraph: Career journey that leads to this role making sense.
   247→        Connect dots between past experiences and this opportunity.
   248→        Show intentional progression toward this type of work.
   249→    stats:
   250→      - value: "X+"
   251→        label: "Relevant Metric 1"
   252→      - value: "Y"
   253→        label: "Relevant Metric 2"
   254→      - value: "Z"
   255→        label: "Relevant Metric 3"
   256→
   257→  sections:
   258→    beyondWork: false  # true if company culture values personal interests
   259→    blog: true         # true if technical writing is valued
   260→    onchainIdentity: false  # true if Web3-native company
   261→    skills: true       # true if technical skills important
   262→    passionProjects: true   # true if side projects demonstrate relevant skills
   263→
   264→relevance:
   265→  caseStudies:
   266→    - slug: "case-study-slug"
   267→      relevanceScore: 0.0-1.0  # 1.0 = highly relevant, 0.0 = not relevant
   268→      reasoning: "One sentence explaining why this is/isn't relevant"
   269→
   270→  skills:
   271→    - category: "Category Name"
   272→      relevanceScore: 0.0-1.0
   273→
   274→  projects:
   275→    - slug: "project-slug"
   276→      relevanceScore: 0.0-1.0
   277→      reasoning: "One sentence explaining relevance"
   278→\`\`\`
   279→
   280→# Guidelines
   281→
   282→1. **Be Truthful**: Only use facts from the portfolio. Don't invent achievements.
   283→2. **Be Specific**: Use concrete numbers, technologies, and outcomes from the background.
   284→3. **Match Language**: Mirror keywords and phrases from the job description naturally.
   285→4. **Prioritize**: Score content by relevance - what demonstrates fit for THIS role?
   286→5. **Tailor Stats**: Choose 3 stats that best demonstrate fit for this role.
   287→6. **Section Visibility**: Only show sections that strengthen the application.
   288→7. **Headline**: Make it memorable and aligned with company values.
   289→
   290→Output ONLY the YAML. No markdown code blocks, no explanations, just valid YAML.`;
   291→}
   292→
   293→// Call AI API
   294→async function callAI(provider: string, apiKey: string, prompt: string): Promise<string> {
   295→  console.log(`${colors.cyan}Calling ${provider} API...${colors.reset}`);
   296→
   297→  if (provider === 'claude') {
   298→    const response = await fetch('https://api.anthropic.com/v1/messages', {
   299→      method: 'POST',
   300→      headers: {
   301→        'Content-Type': 'application/json',
   302→        'x-api-key': apiKey,
   303→        'anthropic-version': '2023-06-01'
   304→      },
   305→      body: JSON.stringify({
   306→        model: 'claude-3-5-sonnet-20241022',
   307→        max_tokens: 4096,
   308→        messages: [{ role: 'user', content: prompt }]
   309→      })
   310→    });
   311→
   312→    if (!response.ok) {
   313→      const error = await response.text();
   314→      throw new Error(`Claude API error: ${response.status} - ${error}`);
   315→    }
   316→
   317→    const data = await response.json();
   318→    return data.content[0].text;
   319→  }
   320→
   321→  if (provider === 'openai') {
   322→    const response = await fetch('https://api.openai.com/v1/chat/completions', {
   323→      method: 'POST',
   324→      headers: {
   325→        'Content-Type': 'application/json',
   326→        'Authorization': `Bearer ${apiKey}`
   327→      },
   328→      body: JSON.stringify({
   329→        model: 'gpt-4-turbo-preview',
   330→        messages: [{ role: 'user', content: prompt }],
   331→        temperature: 0.7
   332→      })
   333→    });
   334→
   335→    if (!response.ok) {
   336→      const error = await response.text();
   337→      throw new Error(`OpenAI API error: ${response.status} - ${error}`);
   338→    }
   339→
   340→    const data = await response.json();
   341→    return data.choices[0].message.content;
   342→  }
   343→
   344→  if (provider === 'gemini') {
   345→    try {
   346→      const response = await fetch(
   347→        `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`,
   348→        {
   349→          method: 'POST',
   350→          headers: {
   351→            'Content-Type': 'application/json'
   352→          },
   353→          body: JSON.stringify({
   354→            contents: [{
   355→              parts: [{ text: prompt }]
   356→            }]
   357→          })
   358→        }
   359→      );
   360→
   361→      if (!response.ok) {
   362→        const error = await response.text();
   363→        throw new Error(`Gemini API error: ${response.status} - ${error}`);
   364→      }
   365→
   366→      const data = await response.json();
   367→      return data.candidates[0].content.parts[0].text;
   368→    } catch (error) {
   369→      console.error('Gemini API fetch error:', error);
   370→      throw error;
   371→    }
   372→  }
   373→
   374→  throw new Error(`Unknown provider: ${provider}`);
   375→}
   376→
   377→// Main execution
   378→async function main() {
   379→  console.log(`${colors.bold}${colors.blue}Universal CV Generator${colors.reset}\n`);
   380→
   381→  try {
   382→    // Parse arguments
   383→    const args = parseArgs();
   384→    console.log(`${colors.gray}Generating variant for: ${colors.reset}${colors.bold}${args.company} - ${args.role}${colors.reset}\n`);
   385→
   386→    // Load portfolio data
   387→    const data = loadPortfolioData();
   388→
   389→    // Generate prompt
   390→    const prompt = generatePrompt(args, data);
   391→
   392→    // Call AI
   393→    const response = await callAI(args.provider, args.apiKey!, prompt);
   394→
   395→    // Parse response (remove code blocks if present)
   396→    let yamlContent = response.trim();
   397→    if (yamlContent.startsWith('\```yaml')) {
   398→      yamlContent = yamlContent.replace(/^\```yaml\n/, '').replace(/\n\```$/, '');
   399→    } else if (yamlContent.startsWith('\```')) {
   400→      yamlContent = yamlContent.replace(/^\```\n/, '').replace(/\n\```$/, '');
   401→    }
   402→
   403→    // Parse and validate
   404→    console.log(`${colors.gray}Validating generated variant...${colors.reset}`);
   405→    const variant = YAML.parse(yamlContent);
   406→    const validated = VariantSchema.parse(variant);
   407→
   408→    // Generate output filenames
   409→    const yamlFile = args.outputFile ||
   410→      join('content', 'variants', `${validated.metadata.slug}.yaml`);
   411→    const jsonFile = yamlFile.replace('.yaml', '.json');
   412→
   413→    // Save to YAML (human-readable)
   414→    writeFileSync(yamlFile, yamlContent, 'utf-8');
   415→
   416→    // Save to JSON (client-side loading)
   417→    writeFileSync(jsonFile, JSON.stringify(validated, null, 2), 'utf-8');
   418→
   419→    console.log(`${colors.green}${colors.bold}✓ Variant generated successfully!${colors.reset}`);
   420→    console.log(`${colors.gray}Saved to:${colors.reset} ${yamlFile}`);
   421→    console.log(`${colors.gray}URL:${colors.reset} /${validated.metadata.company.toLowerCase()}/${validated.metadata.slug.split('-').slice(1).join('-')}`);
   422→
   423→    console.log(`\n${colors.cyan}Next steps:${colors.reset}`);
   424→    console.log(`  1. Review and edit: ${yamlFile}`);
   425→    console.log(`  2. Run validation: npm run validate`);
   426→    console.log(`  3. Test locally: npm run dev`);
   427→    console.log(`  4. Visit: http://localhost:5173/${validated.metadata.company.toLowerCase()}/${validated.metadata.slug.split('-').slice(1).join('-')}`);
   428→
   429→  } catch (error) {
   430→    console.error(`${colors.red}${colors.bold}Error:${colors.reset} ${error instanceof Error ? error.message : error}`);
   431→    process.exit(1);
   432→  }
   433→}
   434→
   435→main();
   436→
```

Result:

```
1→#!/usr/bin/env tsx
     2→/**
     3→ * Variant Sync CLI
     4→ *
     5→ * Canonical source: content/variants/*.yaml
     6→ * Runtime artifact:  content/variants/*.json
     7→ *
     8→ * Why this exists:
     9→ * - The website loads variants as JSON via Vite import.meta.glob.
    10→ * - Humans and agents should edit YAML (reviewable).
    11→ * - JSON must be deterministic and kept in sync (no YAML/JSON drift).
    12→ *
    13→ * Usage:
    14→ *   npm run variants:sync
    15→ *   npm run variants:sync -- --slug mysten-walrus-senior-pm
    16→ *   npm run variants:check
    17→ *   npm run variants:sync -- --json
    18→ */
    19→
    20→import { existsSync, readFileSync, readdirSync, writeFileSync } from 'fs';
    21→import { join } from 'path';
    22→import YAML from 'yaml';
    23→import ora from 'ora';
    24→import { VariantSchema } from '../src/lib/schemas.js';
    25→import { theme, HEADER_COMPACT, kv, box } from './cli/theme.js';
    26→
    27→type Args = {
    28→  slug?: string;
    29→  check: boolean;
    30→  quiet: boolean;
    31→  json: boolean;
    32→};
    33→
    34→type SyncResult = {
    35→  slug: string;
    36→  status: 'synced' | 'updated' | 'created' | 'error';
    37→  message?: string;
    38→};
    39→
    40→function parseArgs(): Args {
    41→  const argv = process.argv.slice(2);
    42→  const out: Args = { check: false, quiet: false, json: false };
    43→  for (let i = 0; i < argv.length; i++) {
    44→    const a = argv[i];
    45→    const n = argv[i + 1];
    46→    if (a === '--slug') {
    47→      out.slug = n;
    48→      i++;
    49→    } else if (a === '--check') {
    50→      out.check = true;
    51→    } else if (a === '--quiet') {
    52→      out.quiet = true;
    53→    } else if (a === '--json') {
    54→      out.json = true;
    55→    }
    56→  }
    57→  return out;
    58→}
    59→
    60→function stableJson(obj: unknown): string {
    61→  return JSON.stringify(obj, null, 2) + '\n';
    62→}
    63→
    64→function listVariantYamlFiles(variantsDir: string): string[] {
    65→  return readdirSync(variantsDir)
    66→    .filter(f => f.endsWith('.yaml'))
    67→    .filter(f => !f.startsWith('_'));
    68→}
    69→
    70→function syncOneVariant(variantsDir: string, yamlFile: string, checkOnly: boolean): SyncResult {
    71→  const slugFromFile = yamlFile.replace(/\.yaml$/, '');
    72→  const yamlPath = join(variantsDir, yamlFile);
    73→  const jsonPath = join(variantsDir, `${slugFromFile}.json`);
    74→
    75→  try {
    76→    const raw = readFileSync(yamlPath, 'utf-8');
    77→    const parsed = YAML.parse(raw);
    78→    const validated = VariantSchema.parse(parsed);
    79→
    80→    if (validated.metadata.slug !== slugFromFile) {
    81→      return {
    82→        slug: slugFromFile,
    83→        status: 'error',
    84→        message: `Slug mismatch: metadata.slug='${validated.metadata.slug}' but filename implies '${slugFromFile}'`
    85→      };
    86→    }
    87→
    88→    const nextJson = stableJson(validated);
    89→    const hadJson = existsSync(jsonPath);
    90→    const prevJson = hadJson ? readFileSync(jsonPath, 'utf-8') : '';
    91→
    92→    if (!hadJson) {
    93→      if (checkOnly) {
    94→        return {
    95→          slug: slugFromFile,
    96→          status: 'error',
    97→          message: `Missing JSON artifact. Run: npm run variants:sync`
    98→        };
    99→      }
   100→      writeFileSync(jsonPath, nextJson, 'utf-8');
   101→      return { slug: slugFromFile, status: 'created' };
   102→    }
   103→
   104→    if (prevJson !== nextJson) {
   105→      if (checkOnly) {
   106→        return {
   107→          slug: slugFromFile,
   108→          status: 'error',
   109→          message: `Drift detected. Run: npm run variants:sync`
   110→        };
   111→      }
   112→      writeFileSync(jsonPath, nextJson, 'utf-8');
   113→      return { slug: slugFromFile, status: 'updated' };
   114→    }
   115→
   116→    return { slug: slugFromFile, status: 'synced' };
   117→  } catch (err) {
   118→    return {
   119→      slug: slugFromFile,
   120→      status: 'error',
   121→      message: err instanceof Error ? err.message : String(err)
   122→    };
   123→  }
   124→}
   125→
   126→async function main() {
   127→  const args = parseArgs();
   128→  const variantsDir = join(process.cwd(), 'content', 'variants');
   129→
   130→  // JSON output mode - minimal, machine-readable
   131→  if (args.json) {
   132→    if (!existsSync(variantsDir)) {
   133→      console.log(JSON.stringify({ variants: [], errors: [] }));
   134→      process.exit(0);
   135→    }
   136→
   137→    const allYaml = listVariantYamlFiles(variantsDir);
   138→    const targets = args.slug ? allYaml.filter(f => f === `${args.slug}.yaml`) : allYaml;
   139→    const results = targets.map(f => syncOneVariant(variantsDir, f, args.check));
   140→
   141→    const output = {
   142→      mode: args.check ? 'check' : 'sync',
   143→      variants: results.filter(r => r.status !== 'error'),
   144→      errors: results.filter(r => r.status === 'error')
   145→    };
   146→
   147→    console.log(JSON.stringify(output, null, 2));
   148→    process.exit(output.errors.length > 0 ? 1 : 0);
   149→  }
   150→
   151→  // Interactive output
   152→  if (!args.quiet) {
   153→    console.log(HEADER_COMPACT);
   154→    console.log();
   155→  }
   156→
   157→  if (!existsSync(variantsDir)) {
   158→    if (!args.quiet) {
   159→      console.log(theme.muted('No variants directory found. Nothing to do.'));
   160→    }
   161→    process.exit(0);
   162→  }
   163→
   164→  const allYaml = listVariantYamlFiles(variantsDir);
   165→  const targets = args.slug ? allYaml.filter(f => f === `${args.slug}.yaml`) : allYaml;
   166→
   167→  if (args.slug && targets.length === 0) {
   168→    console.error(`${theme.icons.error} Variant YAML not found: ${theme.bold(args.slug)}`);
   169→    console.error(theme.muted(`  Expected: content/variants/${args.slug}.yaml`));
   170→    process.exit(1);
   171→  }
   172→
   173→  const spinner = ora({
   174→    text: args.check ? 'Checking variants...' : 'Syncing variants...',
   175→    color: 'yellow'
   176→  }).start();
   177→
   178→  const results: SyncResult[] = [];
   179→
   180→  for (const yamlFile of targets) {
   181→    const result = syncOneVariant(variantsDir, yamlFile, args.check);
   182→    results.push(result);
   183→  }
   184→
   185→  spinner.stop();
   186→
   187→  // Display results
   188→  const updated = results.filter(r => r.status === 'updated' || r.status === 'created');
   189→  const synced = results.filter(r => r.status === 'synced');
   190→  const errors = results.filter(r => r.status === 'error');
   191→
   192→  if (!args.quiet) {
   193→    console.log(theme.bold(args.check ? 'Checking variants' : 'Syncing variants'));
   194→    console.log(theme.muted(variantsDir));
   195→    console.log();
   196→
   197→    for (const r of results) {
   198→      if (r.status === 'error') {
   199→        console.log(`${theme.icons.error} ${r.slug} ${theme.error('error')}`);
   200→        if (r.message) console.log(theme.muted(`  ${r.message}`));
   201→      } else if (r.status === 'created') {
   202→        console.log(`${theme.icons.success} ${r.slug} ${theme.success('(created)')}`);
   203→      } else if (r.status === 'updated') {
   204→        console.log(`${theme.icons.success} ${r.slug} ${theme.warning('(updated)')}`);
   205→      } else {
   206→        console.log(`${theme.icons.success} ${r.slug} ${theme.muted('(in sync)')}`);
   207→      }
   208→    }
   209→
   210→    console.log();
   211→    console.log(theme.muted('Summary:'), `${results.length} variant(s), ${updated.length} updated, ${errors.length} errors`);
   212→  }
   213→
   214→  if (errors.length > 0) {
   215→    process.exit(1);
   216→  }
   217→
   218→  process.exit(0);
   219→}
   220→
   221→main().catch((err) => {
   222→  console.error(`${theme.icons.error} ${theme.error('Fatal:')} ${err instanceof Error ? err.message : String(err)}`);
   223→  process.exit(1);
   224→});
   225→
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Now let me check the other CLI scripts to see more usage patterns:

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Read** `./scripts/evaluate-variants.ts`

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Read** `./scripts/redteam.ts`

Result:

```
1→#!/usr/bin/env tsx
     2→/**
     3→ * Variant Evaluation CLI (Executable Framework)
     4→ *
     5→ * This CLI makes your capstone evaluation framework *operational*.
     6→ *
     7→ * Grounded to this repo:
     8→ * - Variants live in:      content/variants/<slug>.yaml   (canonical, human-editable)
     9→ * - Runtime artifact is:   content/variants/<slug>.json   (what the website loads)
    10→ * - Knowledge base lives:  content/knowledge/**           (source of truth for facts)
    11→ *
    12→ * What this tool produces:
    13→ * - capstone/develop/evals/<slug>.claims.yaml  (machine-checkable "claims ledger")
    14→ * - capstone/develop/evals/<slug>.eval.md      (human checklist + scan summary)
    15→ *
    16→ * The claims ledger is intentionally strict:
    17→ * - It extracts "metric-like" claims (numbers, %, $, ×, +, and quantifiers like "billions", "zero")
    18→ * - Each claim must be VERIFIED against a source file (with anchors)
    19→ * - eval:check will fail if a verified anchor disappears later (regression detection)
    20→ *
    21→ * Usage:
    22→ *   npm run eval:variant -- --slug mysten-walrus-senior-pm
    23→ *   npm run eval:all
    24→ *   npm run eval:check
    25→ *   npm run eval:variant -- --json
    26→ */
    27→
    28→import { existsSync, readFileSync, readdirSync, mkdirSync, writeFileSync } from 'fs';
    29→import { join } from 'path';
    30→import crypto from 'crypto';
    31→import YAML from 'yaml';
    32→import ora from 'ora';
    33→import { VariantSchema } from '../src/lib/schemas.js';
    34→import { theme, HEADER_COMPACT } from './cli/theme.js';
    35→
    36→type VerifyArg = { id: string; sourcePath: string };
    37→
    38→type Args = {
    39→  slug?: string;
    40→  all: boolean;
    41→  check: boolean;
    42→  noWrite: boolean;
    43→  json: boolean;
    44→  verify: VerifyArg[];
    45→};
    46→
    47→type CandidateSource = {
    48→  path: string;
    49→  score: number;
    50→  matchedAnchors: string[];
    51→  note?: string;
    52→};
    53→
    54→type VerifiedSource = {
    55→  path: string;
    56→  anchors: string[];
    57→};
    58→
    59→type ClaimEntry = {
    60→  id: string;
    61→  location: string;
    62→  text: string;
    63→  anchors: string[];
    64→  candidateSources: CandidateSource[];
    65→  verified: {
    66→    status: 'unverified' | 'verified';
    67→    sources: VerifiedSource[];
    68→    notes?: string;
    69→  };
    70→};
    71→
    72→type ClaimsLedger = {
    73→  version: 1;
    74→  variant: {
    75→    slug: string;
    76→    variantFile: string;
    77→    contentHash: string;
    78→    evaluatedAt: string;
    79→  };
    80→  claims: ClaimEntry[];
    81→};
    82→
    83→type EvalResult = {
    84→  slug: string;
    85→  status: 'ok' | 'error';
    86→  claims: number;
    87→  verified: number;
    88→  unverified: number;
    89→  message?: string;
    90→};
    91→
    92→function parseArgs(): Args {
    93→  const argv = process.argv.slice(2);
    94→  const out: Args = { all: false, check: false, noWrite: false, json: false, verify: [] };
    95→
    96→  for (let i = 0; i < argv.length; i++) {
    97→    const a = argv[i];
    98→    const n = argv[i + 1];
    99→    if (a === '--slug') {
   100→      out.slug = n;
```

Result:

```
1→#!/usr/bin/env tsx
     2→/**
     3→ * Red Team Harness CLI (Executable)
     4→ *
     5→ * Turns capstone/develop/red-teaming.md into repeatable scans + a per-variant report.
     6→ *
     7→ * Grounded to this repo:
     8→ * - We red-team the *actual shipped artifacts*: content/variants/<slug>.yaml (canonical)
     9→ * - We enforce traceability via the claims ledger: capstone/develop/evals/<slug>.claims.yaml
    10→ *
    11→ * What it produces:
    12→ * - capstone/develop/redteam/<slug>.redteam.md
    13→ *
    14→ * Usage:
    15→ *   npm run redteam:variant -- --slug mysten-walrus-senior-pm
    16→ *   npm run redteam:all
    17→ *   npm run redteam:check
    18→ *   npm run redteam:check -- --strict   # WARN becomes FAIL
    19→ */
    20→
    21→import { existsSync, readFileSync, readdirSync, mkdirSync, writeFileSync } from 'fs';
    22→import { join } from 'path';
    23→import YAML from 'yaml';
    24→import ora from 'ora';
    25→import { VariantSchema } from '../src/lib/schemas.js';
    26→import { theme, HEADER_COMPACT, kv } from './cli/theme.js';
    27→
    28→type Args = {
    29→  slug?: string;
    30→  all: boolean;
    31→  check: boolean;
    32→  strict: boolean;
    33→  noWrite: boolean;
    34→  quiet: boolean;
    35→  json: boolean;
    36→};
    37→
    38→type RedteamResult = {
    39→  slug: string;
    40→  status: 'pass' | 'warn' | 'fail' | 'error';
    41→  fails: number;
    42→  warns: number;
    43→  reportPath?: string;
    44→  message?: string;
    45→  findings?: Finding[];
    46→};
    47→
    48→type Finding = {
    49→  id: string;
    50→  title: string;
    51→  severity: 'PASS' | 'WARN' | 'FAIL';
    52→  details?: string[];
    53→};
    54→
    55→function parseArgs(): Args {
    56→  const argv = process.argv.slice(2);
    57→  const out: Args = { all: false, check: false, strict: false, noWrite: false, quiet: false, json: false };
    58→
    59→  for (let i = 0; i < argv.length; i++) {
    60→    const a = argv[i];
    61→    const n = argv[i + 1];
    62→    if (a === '--slug') {
    63→      out.slug = n;
    64→      i++;
    65→    } else if (a === '--all') {
    66→      out.all = true;
    67→    } else if (a === '--check') {
    68→      out.check = true;
    69→    } else if (a === '--strict') {
    70→      out.strict = true;
    71→    } else if (a === '--no-write') {
    72→      out.noWrite = true;
    73→    } else if (a === '--quiet') {
    74→      out.quiet = true;
    75→    } else if (a === '--json') {
    76→      out.json = true;
    77→    }
    78→  }
    79→
    80→  // Default: redteam:check checks all variants.
    81→  if (out.check && !out.slug) out.all = true;
    82→
    83→  if (!out.slug && !out.all) {
    84→    throw new Error('Provide --slug <slug> or --all');
    85→  }
    86→  if (out.slug && out.all) {
    87→    throw new Error('Choose either --slug or --all, not both.');
    88→  }
    89→
    90→  return out;
    91→}
    92→
    93→function listVariantSlugs(): string[] {
    94→  const variantsDir = join(process.cwd(), 'content', 'variants');
    95→  if (!existsSync(variantsDir)) return [];
    96→  return readdirSync(variantsDir)
    97→    .filter(f => f.endsWith('.yaml'))
    98→    .filter(f => !f.startsWith('_'))
    99→    .map(f => f.replace(/\.yaml$/, ''));
   100→}
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Let me check if there's a cli directory with more utilities:

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Bash** List all files in scripts directory

`find /Users/dfotesco/Portfolio/portfolio/scripts -type f | head -30`

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Grep** path `./scripts`

Result:

```
/Users/dfotesco/Portfolio/portfolio/scripts/evaluate-variants.ts
/Users/dfotesco/Portfolio/portfolio/scripts/redteam.ts
/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts
/Users/dfotesco/Portfolio/portfolio/scripts/generate-og-images.js
/Users/dfotesco/Portfolio/portfolio/scripts/cli/theme.ts
/Users/dfotesco/Portfolio/portfolio/scripts/validate-content.ts
/Users/dfotesco/Portfolio/portfolio/scripts/generate-cv.ts
```

Result:

```
Found 1 file
scripts/cli/theme.ts
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Perfect! Now let me check for any interactive patterns used in existing scripts and verify the dependencies:

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Grep** path `./package.json`

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Grep** path `./scripts`

Result:

```
Found 1 file
scripts/cli/theme.ts
```

Result:

```
60:    "chalk": "^5.6.2",
66:    "ora": "^9.0.0",
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Let me get more details on how ora is used and check what interactive patterns exist:

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Grep** path `./scripts`

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Bash** Find chalk usage in scripts

`grep -r "import.*chalk" /Users/dfotesco/Portfolio/portfolio/scripts/ | head -10`

Result:

```
/Users/dfotesco/Portfolio/portfolio/scripts/cli/theme.ts:import chalk from 'chalk';
```

Result:

```
scripts/sync-variants.ts:173:  const spinner = ora({
scripts/redteam.ts:433:  const spinner = ora({
scripts/evaluate-variants.ts:627:  const spinner = ora({

[Showing results with pagination = limit: 20, offset: 0]
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Now let me look at how the theme utilities are actually used across the codebase:

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Grep** path `./scripts`

Result:

```
scripts/cli/theme.ts:124:  return `${'  '.repeat(indent)}${theme.icons.bullet} ${text}`;
scripts/cli/theme.ts:131:  const icon = theme.icons[status] || theme.icons.pending;
scripts/sync-variants.ts:25:import { theme, HEADER_COMPACT, kv, box } from './cli/theme.js';
scripts/sync-variants.ts:159:      console.log(theme.muted('No variants directory found. Nothing to do.'));
scripts/sync-variants.ts:168:    console.error(`${theme.icons.error} Variant YAML not found: ${theme.bold(args.slug)}`);
scripts/sync-variants.ts:169:    console.error(theme.muted(`  Expected: content/variants/${args.slug}.yaml`));
scripts/sync-variants.ts:193:    console.log(theme.bold(args.check ? 'Checking variants' : 'Syncing variants'));
scripts/sync-variants.ts:194:    console.log(theme.muted(variantsDir));
scripts/sync-variants.ts:199:        console.log(`${theme.icons.error} ${r.slug} ${theme.error('error')}`);
scripts/sync-variants.ts:200:        if (r.message) console.log(theme.muted(`  ${r.message}`));
scripts/sync-variants.ts:202:        console.log(`${theme.icons.success} ${r.slug} ${theme.success('(created)')}`);
scripts/sync-variants.ts:204:        console.log(`${theme.icons.success} ${r.slug} ${theme.warning('(updated)')}`);
scripts/sync-variants.ts:206:        console.log(`${theme.icons.success} ${r.slug} ${theme.muted('(in sync)')}`);
scripts/sync-variants.ts:211:    console.log(theme.muted('Summary:'), `${results.length} variant(s), ${updated.length} updated, ${errors.length} errors`);
scripts/sync-variants.ts:222:  console.error(`${theme.icons.error} ${theme.error('Fatal:')} ${err instanceof Error ? err.message : String(err)}`);
scripts/redteam.ts:26:import { theme, HEADER_COMPACT, kv } from './cli/theme.js';
scripts/redteam.ts:428:      console.log(theme.muted('No variants found. Nothing to red-team.'));
scripts/redteam.ts:454:    console.log(theme.bold(args.check ? 'Red Team Check' : 'Red Team Scan'));
scripts/redteam.ts:455:    console.log(theme.muted(`${results.length} variant(s)`));
scripts/redteam.ts:460:        console.log(`${theme.icons.error} ${r.slug} ${theme.error('error')}`);
scripts/redteam.ts:461:        if (r.message) console.log(theme.muted(`  ${r.message}`));
scripts/redteam.ts:463:        console.log(`${theme.icons.error} ${r.slug} ${theme.error(`${r.fails} FAIL`)} ${theme.warning(`${r.warns} WARN`)}`);
scripts/redteam.ts:464:        if (r.reportPath) console.log(theme.muted(`  ${r.reportPath}`));
scripts/redteam.ts:466:        console.log(`${theme.icons.warning} ${r.slug} ${theme.warning(`${r.warns} WARN`)}`);
scripts/redteam.ts:467:        if (r.reportPath) console.log(theme.muted(`  ${r.reportPath}`));
scripts/redteam.ts:469:        console.log(`${theme.icons.success} ${r.slug} ${theme.success('passed')}`);
scripts/redteam.ts:475:      theme.muted('Summary:'),
scripts/redteam.ts:490:  console.error(`${theme.icons.error} ${theme.error('Fatal:')} ${err instanceof Error ? err.message : String(err)}`);
scripts/evaluate-variants.ts:34:import { theme, HEADER_COMPACT } from './cli/theme.js';
scripts/evaluate-variants.ts:603:      console.log(theme.muted('No variants found. Nothing to evaluate.'));
scripts/evaluate-variants.ts:639:  console.log(theme.bold(args.check ? 'Checking variants' : 'Evaluating variants'));
scripts/evaluate-variants.ts:640:  console.log(theme.muted(`${slugs.length} variant(s)`));
scripts/evaluate-variants.ts:645:      console.log(`${theme.icons.error} ${r.slug} ${theme.error('failed')}`);
scripts/evaluate-variants.ts:646:      if (r.message) console.log(theme.muted(`  ${r.message}`));
scripts/evaluate-variants.ts:649:        ? theme.warning(`${r.verified}/${r.claims} verified`)
scripts/evaluate-variants.ts:650:        : theme.success(`${r.verified}/${r.claims} verified`);
scripts/evaluate-variants.ts:651:      console.log(`${theme.icons.success} ${r.slug}: ${statusText}`);
scripts/evaluate-variants.ts:653:        console.log(theme.muted(`  Ledger: capstone/develop/evals/${r.slug}.claims.yaml`));
scripts/evaluate-variants.ts:661:    console.log(`${theme.icons.error} ${theme.error(`${errors.length} variant(s) failed`)}`);
scripts/evaluate-variants.ts:668:    console.log(theme.warning(`${theme.icons.warning} ${totalUnverified} unverified claim(s) remaining`));

[Showing results with pagination = limit: 40, offset: 0]
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Perfect! Now let me create a comprehensive report. Let me check for any JSON output patterns and final touches:

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Tool use: **Bash** Check for JSON output and quiet mode patterns

`grep -n "console.log.*JSON.stringify\|--json\|--quiet" /Users/dfotesco/Portfolio/portfolio/scripts/*.ts | head -20`

Result:

```
/Users/dfotesco/Portfolio/portfolio/scripts/evaluate-variants.ts:25: *   npm run eval:variant -- --json
/Users/dfotesco/Portfolio/portfolio/scripts/evaluate-variants.ts:108:    } else if (a === '--json') {
/Users/dfotesco/Portfolio/portfolio/scripts/evaluate-variants.ts:601:      console.log(JSON.stringify({ results: [] }));
/Users/dfotesco/Portfolio/portfolio/scripts/evaluate-variants.ts:619:    console.log(JSON.stringify(output, null, 2));
/Users/dfotesco/Portfolio/portfolio/scripts/redteam.ts:73:    } else if (a === '--quiet') {
/Users/dfotesco/Portfolio/portfolio/scripts/redteam.ts:75:    } else if (a === '--json') {
/Users/dfotesco/Portfolio/portfolio/scripts/redteam.ts:403:      console.log(JSON.stringify({ mode: args.check ? 'check' : 'redteam', results: [], errors: [] }));
/Users/dfotesco/Portfolio/portfolio/scripts/redteam.ts:415:    console.log(JSON.stringify(output, null, 2));
/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts:17: *   npm run variants:sync -- --json
/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts:51:    } else if (a === '--quiet') {
/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts:53:    } else if (a === '--json') {
/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts:133:      console.log(JSON.stringify({ variants: [], errors: [] }));
/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts:147:    console.log(JSON.stringify(output, null, 2));
```

_**Agent (claude-haiku-4-5-20251001) (sidechain)**_

Excellent! Now I have a complete picture. Let me create a comprehensive exploration report:

## CLI Theme and Styling Implementation Analysis

I've thoroughly explored your CLI implementation. Here's what I found:

### 1. **Theme Module** (`scripts/cli/theme.ts`)

Your theme system is well-architected and uses **chalk** for colored terminal output:

**Color Palette:**
- **Brand accent**: `#c29a6c` (tan) - from design system
- **Success**: `#4ade80` (green)
- **Warning**: `#facc15` (yellow)
- **Error**: `#ef4444` (red)
- **Info**: `#60a5fa` (blue)
- **Muted**: `#6b7280` (gray)

**Key Features:**
```typescript
// Semantic functions
theme.brand()         // Tan accent color
theme.success()       // Green text
theme.error()         // Red text
theme.warning()       // Yellow text
theme.info()          // Blue text
theme.muted()         // Gray text

// Text styling
theme.bold()          // Bold text
theme.dim()           // Dimmed text
theme.italic()        // Italic text

// Status icons (colored unicode)
theme.icons.success   // ✓ (green)
theme.icons.error     // ✗ (red)
theme.icons.warning   // ⚠ (yellow)
theme.icons.info      // ℹ (blue)
theme.icons.pending   // ○ (gray)
theme.icons.running   // ● (blue)
theme.icons.bullet    // • (gray)

// Badges
theme.badge.pass      // "PASS" (green bold)
theme.badge.fail      // "FAIL" (red bold)
theme.badge.warn      // "WARN" (yellow bold)
```

**Layout Utilities:**
```typescript
header(title, subtitle?)     // Section headers with divider
box(title, content)          // Boxed content with borders
kv(key, value)              // Key-value pairs
li(text, indent)            // List items with bullets
step(status, text)          // Process steps with icons
progressBar(percent, width) // Colored progress bar

// Helper functions
isInteractive()             // TTY detection
shouldUseColor()            // Color capability detection
```

### 2. **Dependencies Available**

Your `package.json` has minimal CLI dependencies:

```json
{
  "chalk": "^5.6.2",  // Terminal colors
  "ora": "^9.0.0"     // Spinners/loading indicators
}
```

**Note:** No interactive CLI libraries are installed yet:
- No `inquirer` (prompts/selections)
- No `prompts` (lightweight prompts)
- No `ink` (React for CLI)
- No `blessed` (full TUI)

### 3. **How Existing Scripts Use the Theme**

All CLI scripts follow a consistent pattern:

**`sync-variants.ts` Example:**
```typescript
import { theme, HEADER_COMPACT, kv, box } from './cli/theme.js';

// Display header
console.log(HEADER_COMPACT);

// Spinner for long operations
const spinner = ora({
  text: 'Syncing variants...',
  color: 'yellow'
}).start();

// Results with themed icons
for (const r of results) {
  if (r.status === 'error') {
    console.log(`${theme.icons.error} ${r.slug} ${theme.error('error')}`);
  } else if (r.status === 'created') {
    console.log(`${theme.icons.success} ${r.slug} ${theme.success('(created)')}`);
  }
}

spinner.stop();
```

**Pattern in all scripts:**
1. Import theme utilities at top
2. Parse CLI args manually (no library)
3. Show `HEADER_COMPACT` when not in `--quiet` mode
4. Use theme functions for visual feedback
5. Support `--json` flag for machine-readable output
6. Support `--quiet` flag to suppress output

### 4. **Interactive Patterns Currently Used**

**Limited interactivity - mostly non-interactive:**

- **Spinners**: `ora()` for loading states (sync-variants, evaluate-variants, redteam)
- **CLI Arguments**: Manual parsing with `process.argv.slice(2)`
- **Exit codes**: Proper exit codes for success/failure
- **TTY Detection**: `isInteractive()` checks if running in terminal
- **JSON Output**: `--json` flag for programmatic use

**Not currently used:**
- No prompts or user input
- No selections or confirmations
- No interactive menus
- No text input fields

### 5. **Design Patterns Worth Noting**

**Dual Output Modes:**
- Human-readable (colored, formatted)
- Machine-readable (`--json`)

**Graceful Degradation:**
- Respects `NO_COLOR` and `UCV_NO_COLOR` env vars
- Respects `UCV_NON_INTERACTIVE` flag
- Works in CI/CD environments (detects via `process.env.CI`)

**Command Structure:**
```typescript
// Typical pattern
function parseArgs(): Args {
  const argv = process.argv.slice(2);
  const out: Args = { /* defaults */ };
  
  for (let i = 0; i < argv.length; i++) {
    const arg = argv[i];
    const next = argv[i + 1];
    switch (arg) {
      case '--flag': out.flag = next; i++; break;
    }
  }
  return out;
}

async function main() {
  try {
    const args = parseArgs();
    // ... do work
  } catch (error) {
    console.error(`${theme.icons.error} ${theme.error('Fatal:')} ${error.message}`);
    process.exit(1);
  }
}

main();
```

### 6. **Key Observations for Your Interactive CLI Design**

**Strengths to leverage:**
- Consistent color scheme already defined
- Theme utilities are reusable
- Proper error handling patterns
- Support for non-interactive modes (CI/CD friendly)
- Exit code discipline

**Missing for interactive UIs:**
- No prompt library (you'll want to add `prompts` or `inquirer`)
- No menu/selection widgets
- No form input handling
- No real-time keyboard event handling

**Recommendations for interactive CLI:**
1. **For simple prompts**: Add `prompts` package (lightweight, async)
2. **For rich menus**: Consider `ink` (React component model) or `blessed` (TUI framework)
3. **Keep the theme module** as your foundation
4. **Maintain dual modes**: Keep `--json` and `--quiet` flags
5. **Preserve TTY detection**: Use `isInteractive()` to fall back to non-interactive modes

### File Locations Summary

- **Theme Module**: `/Users/dfotesco/Portfolio/portfolio/scripts/cli/theme.ts`
- **Usage Examples**: 
  - `/Users/dfotesco/Portfolio/portfolio/scripts/sync-variants.ts` (best example)
  - `/Users/dfotesco/Portfolio/portfolio/scripts/evaluate-variants.ts`
  - `/Users/dfotesco/Portfolio/portfolio/scripts/redteam.ts`
- **Older CLI** (pre-theme): `/Users/dfotesco/Portfolio/portfolio/scripts/validate-content.ts` (uses raw ANSI codes)
- **CV Generator** (pre-theme): `/Users/dfotesco/Portfolio/portfolio/scripts/generate-cv.ts` (uses raw ANSI codes)

This gives you a solid foundation for building interactive CLI features while maintaining consistency with your existing design system!

